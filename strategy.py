import pandas as pd
import numpy as np # Explicitly import numpy as it's allowed and pandas depends on it

def generate_signals(candles_target: pd.DataFrame, candles_anchor: pd.DataFrame) -> pd.DataFrame:
    """
    Strategy: Buy LDO if BTC or ETH pumped >2% exactly 4 hours ago.
    If no buy condition is met, HOLD. No SELL signals are generated by this specific strategy.

    Inputs:
    - candles_target: OHLCV for the target coin (e.g., LDO 1H)
                      Columns: ['timestamp', 'open', 'high', 'low', 'close', 'volume']
    - candles_anchor: Merged OHLCV for anchor coins (e.g., BTC 1H, ETH 1H)
                      Columns: ['timestamp', 'open_BTC', 'high_BTC', ..., 'close_ETH', ...]

    Output:
    - DataFrame with ['timestamp', 'signal'] columns, where signal is 'BUY' or 'HOLD'.
      The length of the output DataFrame must match candles_target.
    """
    # Initialize the output DataFrame with the same index and timestamps as candles_target
    signals_df = pd.DataFrame(index=candles_target.index)
    signals_df['timestamp'] = candles_target['timestamp']
    signals_df['signal'] = 'HOLD'  # Default signal

    # Ensure data is sorted by timestamp if not already (important for pct_change and shift)
    # The platform should provide sorted data, but a check or sort here can add robustness.
    # For this implementation, we assume data is pre-sorted as per typical financial time series.
    
    # Merge anchor data with the target data's timestamps to align them
    # We use a left merge to ensure all target timestamps are preserved.
    # The `candles_anchor` should ideally have all timestamps present in `candles_target`.
    # If not, there will be NaNs for anchor data on some rows.
    merged_df = pd.merge(candles_target[['timestamp']], 
                         candles_anchor, 
                         on='timestamp', 
                         how='left')

    # Get metadata to find anchor symbols
    metadata = get_coin_metadata()
    anchor_symbols = [anchor['symbol'] for anchor in metadata['anchors']]

    buy_condition_met = pd.Series([False] * len(merged_df), index=merged_df.index)

    for anchor_sym in anchor_symbols:
        close_col = f'close_{anchor_sym}'
        if close_col in merged_df.columns:
            # Calculate 1-period percentage change for the anchor coin
            anchor_return = merged_df[close_col].pct_change()
            # Shift this return by the lag period (4 hours = 4 periods if timeframe is 1H)
            # The value at row `i` will be the return from row `i-4` (relative to `i-5`)
            anchor_return_lagged = anchor_return.shift(4)
            
            # Check for pump condition (return > 2%)
            # NaNs in anchor_return_lagged (e.g. at the start due to shift/pct_change)
            # will result in False when compared, which is desired (no signal if not enough data).
            pump_condition = anchor_return_lagged > 0.02
            buy_condition_met = buy_condition_met | pump_condition.fillna(False)
        else:
            # This case should ideally not happen if metadata and data are consistent.
            # Consider logging or raising a warning if a declared anchor's data is missing.
            pass 
            
    # Apply BUY signal where the condition was met
    signals_df.loc[buy_condition_met, 'signal'] = 'BUY'
    
    # The signals_df already has the correct length and timestamps from candles_target.
    # The 'signal' column is updated based on conditions from merged_df, 
    # which shares the same index after the loc assignment if buy_condition_met's index is aligned.
    # Since buy_condition_met is derived from merged_df, and merged_df is left-merged from candles_target,
    # their indices should align if timestamps are unique and sorted.
    # If merged_df's index is not perfectly aligned with signals_df after operations, 
    # ensure alignment before assignment or use map based on timestamp.
    # However, given the setup, direct assignment with .loc should work if indices are consistent.

    # Final check to ensure the structure is as expected by the submission checker
    # The problem statement implies `candles_target` and `candles_anchor` are already aligned by timestamp
    # and `candles_anchor` is a single DataFrame with all anchor data. My merge strategy is robust.

    return signals_df[['timestamp', 'signal']]

def get_coin_metadata() -> dict:
    """
    Specifies the target and anchor coins used in this strategy.
    Target coin (LDO) must have avg daily USD volume >= $5M (Jan 1 2025 - May 9 2025 UTC).
    Anchor coins must be BTC, ETH, or SOL.
    Timeframes must be 1H, 4H, or 1D.

    Returns:
    {
        "target": {"symbol": "LDO", "timeframe": "1H"},
        "anchors": [
            {"symbol": "BTC", "timeframe": "1H"},
            {"symbol": "ETH", "timeframe": "1H"}
        ]
    }
    """
    return {
        "target": {
            "symbol": "LDO",
            "timeframe": "1H"
        },
        "anchors": [
            {"symbol": "BTC", "timeframe": "1H"},
            {"symbol": "ETH", "timeframe": "1H"}
        ]
    }

# Example usage for local testing (not part of the core strategy logic for submission, but helpful)
if __name__ == '__main__':
    print("Running local test for the strategy...")
    
    # Create sample dataframes as per the starter kit's expectations
    timestamps = pd.to_datetime([
        '2025-01-01 00:00:00', '2025-01-01 01:00:00', '2025-01-01 02:00:00', 
        '2025-01-01 03:00:00', '2025-01-01 04:00:00', '2025-01-01 05:00:00',
        '2025-01-01 06:00:00', '2025-01-01 07:00:00', '2025-01-01 08:00:00',
        '2025-01-01 09:00:00'
    ], utc=True)

    candles_target_data = {
        'timestamp': timestamps,
        'open':  [1.0, 1.1, 1.05, 1.12, 1.15, 1.13, 1.18, 1.20, 1.22, 1.19],
        'high':  [1.1, 1.12, 1.08, 1.15, 1.18, 1.16, 1.20, 1.23, 1.25, 1.22],
        'low':   [0.98, 1.03, 1.01, 1.09, 1.12, 1.10, 1.15, 1.18, 1.19, 1.17],
        'close': [1.05, 1.08, 1.10, 1.13, 1.12, 1.15, 1.19, 1.21, 1.18, 1.20],
        'volume': [1000, 1200, 1100, 1300, 900, 1500, 1400, 1600, 1000, 1700]
    }
    ct_df = pd.DataFrame(candles_target_data)

    candles_anchor_data = {
        'timestamp': timestamps,
        'open_BTC':  [20000, 20100, 20050, 20120, 20150, 20130, 20180, 20200, 20220, 20190],
        'high_BTC':  [20100, 20120, 20080, 20150, 20180, 20160, 20200, 20230, 20250, 20220],
        'low_BTC':   [19980, 20030, 20010, 20090, 20120, 20100, 20150, 20180, 20190, 20170],
        'close_BTC': [20050, 20080, 19000, 20130, 20120, 20150, 20190, 20210, 20180, 20200], # BTC pump at index 2 (19000 -> 20080 is not a pump, let's make one)
        'volume_BTC':[100, 120, 110, 130, 90, 150, 140, 160, 100, 170],
        'open_ETH':  [1000, 1010, 1005, 1012, 1015, 1013, 1018, 1020, 1022, 1019],
        'high_ETH':  [1010, 1012, 1008, 1015, 1018, 1016, 1020, 1023, 1025, 1022],
        'low_ETH':   [998, 1003, 1001, 1009, 1012, 1010, 1015, 1018, 1019, 1017],
        'close_ETH': [1005, 1008, 1010, 1013, 1012, 1015, 1019, 1021, 1018, 1020],
        'volume_ETH':[200, 220, 210, 230, 190, 250, 240, 260, 200, 270]
    }
    # Create a pump for BTC at index 1 to trigger a signal at index 1+4=5
    # Original close at index 0: 20050. New close at index 1: 20050 * 1.03 = 20651.5
    candles_anchor_data['close_BTC'][1] = 20651.5 

    ca_df = pd.DataFrame(candles_anchor_data)

    print("Sample Target Candles:")
    print(ct_df)
    print("\nSample Anchor Candles:")
    print(ca_df)

    signals_output = generate_signals(ct_df, ca_df)

    print("\nGenerated Signals:")
    print(signals_output)

    # Expected: BUY signal at index 5 because BTC pumped at index 1 (close_BTC[1] > close_BTC[0] * 1.02)
    # pct_change at index 1: (20651.5 - 20050) / 20050 = 0.03
    # This 0.03 is shifted by 4, so it appears at index 1+4 = 5 in anchor_return_lagged
    # So, signals_df.loc[5, 'signal'] should be 'BUY'
    if not signals_output.empty and len(signals_output) > 5 and signals_output.loc[5, 'signal'] == 'BUY':
        print("\nTest PASSED: BUY signal correctly generated at index 5 for BTC pump.")
    else:
        print("\nTest FAILED: BUY signal not generated as expected or DataFrame too short.")
        if len(signals_output) > 5:
            print(f"Signal at index 5: {signals_output.loc[5, 'signal']}")

    # Test with an ETH pump
    candles_anchor_data_eth_pump = {
        'timestamp': timestamps,
        'open_BTC': candles_anchor_data['open_BTC'], 'high_BTC': candles_anchor_data['high_BTC'], 
        'low_BTC': candles_anchor_data['low_BTC'], 'close_BTC': [20000]*10, # No BTC pump
        'volume_BTC': candles_anchor_data['volume_BTC'],
        'open_ETH': candles_anchor_data['open_ETH'], 'high_ETH': candles_anchor_data['high_ETH'],
        'low_ETH': candles_anchor_data['low_ETH'], 
        'close_ETH': [1005, 1008, 1030, 1013, 1012, 1015, 1019, 1021, 1018, 1020], # ETH pump at index 2
        'volume_ETH': candles_anchor_data['volume_ETH']
    }
    # ETH pump at index 2: (1030 - 1008) / 1008 = 0.0218
    candles_anchor_data_eth_pump['close_ETH'][1] = 1008 # Previous close for pct_change
    candles_anchor_data_eth_pump['close_ETH'][2] = 1008 * 1.03 # Pump
    ca_df_eth = pd.DataFrame(candles_anchor_data_eth_pump)
    signals_output_eth = generate_signals(ct_df, ca_df_eth)
    print("\nGenerated Signals (ETH Pump Test):")
    print(signals_output_eth)
    if not signals_output_eth.empty and len(signals_output_eth) > 6 and signals_output_eth.loc[6, 'signal'] == 'BUY':
        print("\nTest PASSED: BUY signal correctly generated at index 6 for ETH pump at index 2.")
    else:
        print("\nTest FAILED: BUY signal for ETH pump not generated as expected or DataFrame too short.")
        if len(signals_output_eth) > 6:
            print(f"Signal at index 6: {signals_output_eth.loc[6, 'signal']}")

